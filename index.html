<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Solitaire (Klondike)</title>
  <style>
	:root {
	  --card-w: clamp(72px, 14vw, 120px);
	  --card-h: calc(var(--card-w) * 1.4);
	  --card-gap: clamp(6px, 2vw, 12px);
	  
	  --tableau-w: calc(
		(var(--card-w) * 7) + (var(--card-gap) * 6)
	  );
	}
    body { background:#0b6623; color:#fff; font-family:sans-serif; 
		   overscroll-behavior: none; max-width: 100vw; overflow-x: hidden; position: relative; /* â­ ì—¬ê¸° í•„ìˆ˜ */}
    .board { display:flex; flex-direction:column; gap:20px; padding:20px; width:40%;}
    .row { display:flex; gap:12px; }
	.timer {
	  position: absolute;
	  top: 10px; /* ì¹´ë“œ ìœ„ìª½ì— ì‚´ì§ ë„ìš°ê¸°, í•„ìš”ì— ë”°ë¼ ì¡°ì • */
	  left: calc(var(--card-w) * 6 + var(--card-gap) * 6); /* 7ë²ˆì§¸ ì¹´ë“œ ìœ„ì¹˜ */
	  width: var(--card-w); /* ì¹´ë“œ í­ê³¼ ë™ì¼ */
	  text-align: center;   /* ê°€ìš´ë° ì •ë ¬ */
	  font-size: 20px;
	  font-weight: bold;
	  background: rgba(255,255,255,0.8);
	  color: #222;
	  padding: 10px;
	  border-radius: 4px;
	  pointer-events: none;
	  z-index: 500;
	}
	
	.win-overlay {
	  position: fixed;
	  inset: 0;
	  background: rgba(0, 0, 0, 0.65); /* ë°˜íˆ¬ëª… ë°°ê²½ */
	  display: none;                   /* ì´ˆê¸° ìˆ¨ê¹€ */
	  align-items: center;
	  justify-content: center;
	  z-index: 999;
	}
	.win-box {
	  pointer-events: auto;
	  background: #fff;
	  color: #111;
	  padding: 20px;
	  border-radius: 12px;
	  box-shadow: 0 6px 18px rgba(0,0,0,0.35);
	  text-align: center;
	  width: 200px;
	  height: 220px;
	  display: flex;
	  flex-direction: column;
	  justify-content: center;
	  align-items: center;
	  position: absolute;
	  top: 50%;  /* í™”ë©´ ì„¸ë¡œ ì¤‘ì•™ */
	  left: calc(var(--tableau-w) / 2);  /* ì¹´ë“œ 7ì¥ì˜ í­ ì¤‘ì•™ */
	  transform: translate(-50%, -50%);   /* ì •í™•íˆ ì¤‘ì•™ ë§ì¶¤ */
	  font-family: 'Segoe UI', sans-serif;
	}
	.win-box h1 {
	  margin: 0 0 16px;
	  font-size: clamp(24px, 5vw, 36px);
	}
	.win-box p {
	  font-size: 18px;
	  margin: 8px 0 20px;
	}
	.win-box button {
	  margin-top: 10px;
	  padding: 12px 24px;
	  font-size: 16px;
	  font-weight: bold;
	  color: #fff;
	  background: #28a745;
	  border: none;
	  border-radius: 8px;
	  cursor: pointer;
	  transition: background 0.2s;
	}
	.win-box button:hover {
	  background: #218838;
	}
	/* ê°„ë‹¨í•œ ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ */
	@keyframes popIn {
	  0% { transform: scale(0.5); opacity: 0; }
	  100% { transform: scale(1); opacity: 1; }
	}

	#top {
	  display: grid;
	  grid-template-columns: repeat(7, var(--card-w));
	  gap: var(--card-gap);
	  width: fit-content;
	}
	#tableau {
	  display: grid;
	  grid-template-columns: repeat(7, var(--card-w));
	  gap: var(--card-gap);
	}
	#actionBarBottom {
	  width: var(--tableau-w);
	  position: fixed;
	  bottom: 20px;
	  display: flex;
	  justify-content: space-between;
	  margin-top: 12px;
	  z-index: 1000;
	}
	#actionBarBottom button {
	  min-width: 120px;
	  padding: 10px 10px;
	  font-size: 20px;
	  border-radius: 8px;

	  border: none;                    /* í…Œë‘ë¦¬ ì œê±° */
	  background: rgba(255,255,255,0.8); /* íƒ€ì´ë¨¸ ë°°ê²½ì²˜ëŸ¼ ë°˜íˆ¬ëª… */
	  color: #222;                     /* íƒ€ì´ë¨¸ ê¸€ì”¨ ìƒ‰ê³¼ ë§ì¶¤ */
	  cursor: pointer;

	  box-shadow: none;                /* ì…ì²´ê° ì œê±° */
	}
	
	.hint {
	  box-shadow:
		0 0 0 5px gold inset,
		0 0 28px 12px rgba(255, 215, 0, 1);
	  animation: hintPulse 0.7s infinite;
	  z-index: 100;							
	}	
	@keyframes hintPulse {
	  0%   { box-shadow: 0 0 0 5px gold inset, 0 0 16px rgba(255,215,0,0.9); }
	  50%  { box-shadow: 0 0 0 5px gold inset, 0 0 32px rgba(255,215,0,1); }
	  100% { box-shadow: 0 0 0 5px gold inset, 0 0 16px rgba(255,215,0,0.9); }
	}
	
    .pile {
	  width: var(--card-w);
	  min-height: var(--card-h);
	  border:1px solid rgba(255,255,255,0.3);
	  border-radius:6px;
	  position:relative;
	}
    .card {
	  width: var(--card-w);
      height: var(--card-h);
	  border-radius:6px;
	  background:#fff;
	  position:absolute;
	  cursor:pointer;
	  outline: 3px solid black;
	  cursor: grab;
	}
	.card:active {
	  cursor: grabbing;
	}
	.card .label {
	  position: absolute;
	  right: 8px;
	  font-size: clamp(50px, 4vw, 30px);
	  font-weight: 800;
	  line-height: 1;
	  text-shadow: 0 1px 0 rgba(255,255,255,0.6);	  
	}
	.red { color: #c60000; }
	.black { color: #111; }
    .center-suit {
	  position: absolute;
	  inset: 0;
	  display: flex;
	  align-items: end;
	  justify-content: center;
	  font-size: clamp(100px, 14vw, 72px);
	  opacity: 0.95;
	  font-weight: 900;
	  pointer-events: none;
	  user-select: none;	  
	}
	.center-suit.red {
	  color: rgb(200, 0, 40);   /* ì§„í•œ ë ˆë“œ */
	}
	.center-suit.black {
	  color: rgb(10, 10, 10);   /* ê±°ì˜ ë¸”ë™ */
	}
	.back {
	  background: repeating-linear-gradient(
		45deg,
		#1e90ff,
		#1e90ff 10px,
		#1565c0 10px,
		#1565c0 20px
	  );
	}
	
	@keyframes firework {
	  0% {
		transform: translate(0,0) rotate(0deg);
		opacity: 1;
	  }
	  100% {
		transform:
		  translate(
			calc((Math.random() - 0.5) * 600px),
			-600px
		  )
		  rotate(720deg);
		opacity: 0;
	  }
	}
	.firework {
	  animation: firework 1.2s ease-out forwards;
	}
	
	/* ëª¨ë°”ì¼ ëŒ€ì‘ ì˜ˆì‹œ */
	@media (max-width: 600px) {
	  :root {
		--card-w: 104px;
		--card-h: 148px;
		--card-gap: 6px;
	  }
	  body {
		font-size: 16px;
		touch-action: manipulation;   /* íƒ­ ì‹œ í™•ëŒ€ ë°©ì§€ */
		-ms-touch-action: manipulation; /* IE/Edge ëŒ€ì‘ */
		overscroll-behavior: none;   /* ìŠ¤í¬ë¡¤ íŠ ë°©ì§€ */
		}	  
	  #actionBarBottom {
		width: 100%;
		flex-direction: column;
		gap: 12px;
	  }
	  #leftBtn {
		display: flex;
		gap: 8px;
	  }
	  #leftBtn button,
	  #autoCompleteBtn {
		flex: 1;
	  }
	  #undoBtn, #refreshBtn, #autoCompleteBtn, #hintBtn {
		padding:16px 20px;
		font-size:18px;
	  }
	  
	  .pile {
		width:100px;
		min-height:140px;
	  }
	  .card {
		width:100px;
		height:140px;
	  }
	  .card .label {
		font-size:16px;
	  }	  
	}	
  </style>
</head>
<body>
  <h1>ğŸƒ ì†”ë¦¬í…Œì–´ (í´ë¡ ë‹¤ì´í¬)</h1>
	<div id="timer" class="timer">â± 00:00</div>
	<br/>
	<button id="testAutoBtn">ğŸ†ìë™ì™„ì„±í…ŒìŠ¤íŠ¸</button>
	
  <div class="board">	
    <div class="row" id="top">
	  <div class="pile foundation" data-suit="â™ " style="grid-column:1"></div>
	  <div class="pile foundation" data-suit="â™¥" style="grid-column:2"></div>
	  <div class="pile foundation" data-suit="â™¦" style="grid-column:3"></div>
	  <div class="pile foundation" data-suit="â™£" style="grid-column:4"></div>
	  
	  <div class="pile" id="waste" style="grid-column:6"></div>
	  <div class="pile" id="stock" style="grid-column:7"></div>
	</div>	
    <div class="row" id="tableau"></div>
	
	<div id ="actionBarBottom">
		<div id = "leftBtn">
		  <button id="refreshBtn">ğŸ”„ìƒˆë¡œê³ ì¹¨</button>
		  <button id="undoBtn">â†©ï¸ì‹¤í–‰ì·¨ì†Œï¸</button>
		  <button id="hintBtn">ğŸ’¡íŒíŠ¸</button>		  
		</div>
	  <button id="autoCompleteBtn">ğŸ†ìë™ì™„ì„±ğŸ†</button>
	</div>

	<!-- ìŠ¹ë¦¬ ì˜¤ë²„ë ˆì´ UI -->	
	<div id="winOverlay" class="win-overlay">
	  <div class="win-box">
		<h1>ğŸ‰<br/>CLEAR!</h1>
		<p id="winTime"></p>
		<button onclick="location.reload()" style="
			margin-top:20px;
			font-size:18px;
			padding:10px 20px;
			cursor:pointer;
		  ">ë‹¤ì‹œí•˜ê¸°</button>
		</div>
	  </div>
	</div>

	<!-- íŒíŠ¸ ì˜¤ë²„ë ˆì´ -->
	<div id="hintOverlay" style="
	  position: fixed;
	  inset: 0;
	  pointer-events: none;
	  z-index: 2000;
	"></div>
<script>
const suits = ['â™ ','â™¥','â™¦','â™£'];
const values = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
let deck = [];
let stock = [], waste = [];
let tableau = [[],[],[],[],[],[],[]];
let history = []; // ì „ì²´ ìƒíƒœ ì €ì¥ìš©
let cardId = 0;
let foundations = {
  'â™ ': [],
  'â™¥': [],
  'â™¦': [],
  'â™£': []
};
let startTime = null;
let timerInterval = null;

//íŒíŠ¸ ìˆœí™˜ì„ ìœ„í•œ ìƒíƒœ ë³€ìˆ˜
let hintList = [];
let hintIndex = 0;
let usedHints = new Set();
let currentHint = null;
let movedOnce = false;

document.getElementById('refreshBtn').onclick = () => {
    location.reload();
};

// íƒ€ì´ë¨¸ ì‹œì‘ ì‹œ + ë§¤ ì´ˆ ìœ„ì¹˜ ê°±ì‹ 
function startTimer() {
  startTime = Date.now();
  const timerEl = document.getElementById('timer');

  timerInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;
    updateTimerUI(elapsed);
    updateTimerPosition(); // â­ ìœ„ì¹˜ ê°±ì‹ 
  }, 1000);
}

//íƒ€ì´ë¨¸ ì •ì§€(ìŠ¹ë¦¬)
function stopTimer() {
  clearInterval(timerInterval);
  timerInterval = null;
}

//ì‹œê°„í‘œì‹œ
function updateTimerUI(ms) {
  const totalSec = Math.floor(ms / 1000);
  const min = String(Math.floor(totalSec / 60)).padStart(2, '0');
  const sec = String(totalSec % 60).padStart(2, '0');

  document.getElementById('timer').textContent = `â± ${min}:${sec}`;
}

//ê²Œì„ì‹œì‘
function startGame() {
  createDeck();
  deal();
  render();
  startTimer();
}

//ë± ìƒì„±
function createDeck() {
  deck = [];
  for (let s of suits) {
    for (let v of values) {
      deck.push({
        id: cardId++,   // â­ ê³ ìœ  ID
        suit: s,
        value: v,
        faceUp: false
      });
    }
  }
  deck.sort(() => Math.random() - 0.5);
}

//ì¹´ë“œë°°ì¹˜
function deal() {
  for (let i=0;i<7;i++) {
    for (let j=0;j<=i;j++) {
      const card = deck.pop();
      if (j === i) card.faceUp = true;
      tableau[i].push(card);
    }
  }
  stock = deck;
}

function render() {
  document.getElementById('stock').innerHTML = '';
  document.getElementById('waste').innerHTML = '';

  // stock
  if (stock.length || waste.length) {
	  const c = document.createElement('div');
	  c.className = 'card back';
	  c.onclick = drawCard;
	  document.getElementById('stock').appendChild(c);
	}

  // waste
  if (waste.length) {
    const card = waste[waste.length-1];
    document.getElementById('waste')
      .appendChild(cardEl(card, {type:'waste'}));
  }

  /* =====================
     tableau ë Œë”
     ===================== */
  const tab = document.getElementById('tableau');
  tab.innerHTML = '';

  tableau.forEach((col, colIdx) => {
	  const p = document.createElement('div');
	  p.className = 'pile';

	  let topOffset = 0; // â­â­â­ ì—¬ê¸°! ì»¬ëŸ¼ë§ˆë‹¤ ì´ˆê¸°í™”

	  p.onclick = (e) => {
		if (e.target !== p) return;
		onPileClick({ type:'tableau', index:colIdx });
	  };
	    // ğŸ”½ ë“œë˜ê·¸ í—ˆìš© (í•„ìˆ˜)
	  p.ondragover = (e) => {
		e.preventDefault(); // ì´ê±° ì—†ìœ¼ë©´ drop ì•ˆë¨
	  };

	  // ğŸ”½ ë“œë¡­ ì‹œ ì´ë™
	  p.ondrop = (e) => {
		e.preventDefault();
		onPileClick({ type:'tableau', index:colIdx });
	  };

	  col.forEach((card) => {
		const el = cardEl(card, { type:'tableau', index:colIdx });

		if (!card.faceUp) {
		  el.style.top = topOffset + 'px';
		  topOffset += 30;   // ë’¤ì§‘íŒ ì¹´ë“œ
		} else {
		  el.style.top = topOffset + 'px';
		  topOffset += 55;   // í¼ì³ì§„ ì¹´ë“œ
		}

		p.appendChild(el);
	  });

	  tab.appendChild(p);
	});

  /* =====================
     foundation ë Œë”
     ===================== */
  document.querySelectorAll('.foundation').forEach(f => {
	  const suit = f.dataset.suit;
	  f.innerHTML = '';

	  const pile = foundations[suit];

	  if (pile.length) {
		const card = pile[pile.length - 1];
		f.appendChild(cardEl(card, { type:'foundation', suit }));
	  } else {
		// â­ ë¬´ëŠ¬ í‘œì‹œ
		const hint = document.createElement('div');
		hint.style.position = 'absolute';
		hint.style.inset = '0';
		hint.style.display = 'flex';
		hint.style.alignItems = 'center';
		hint.style.justifyContent = 'center';
		hint.style.fontSize = '100px';
		hint.style.opacity = '0.3';
		hint.textContent = suit;
		f.appendChild(hint);
	  }

	  f.onclick = () =>
		onFoundationClick({ type:'foundation', suit });
	});
	
	// ë§ˆì§€ë§‰ì— ë²„íŠ¼ ìƒíƒœ ê°±ì‹ 
	updateAutoCompleteButton();
	createUndoButton(); // í•­ìƒ ë²„íŠ¼ ìƒì„±
}

//ì¹´ë“œ ë§Œë“¤ê¸°
function cardEl(card, fromInfo) {
	
  const d = document.createElement('div');
  d.className = 'card ' + ((card.suit==='â™¥'||card.suit==='â™¦') ? 'red' : 'black');

  if (!card.faceUp) d.classList.add('back');

  if (card.faceUp) {
    // ì¢Œìƒë‹¨ ìˆ«ì + ë¬´ëŠ¬
    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = card.value;
    d.appendChild(label);

    // ì¤‘ì•™ í° ë¬´ëŠ¬
    const center = document.createElement('div');
    center.className = 'center-suit';
    center.textContent = card.suit;
    d.appendChild(center);
  }

  // ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸
  d.onclick = (e) => { e.stopPropagation(); onCardClick(card, fromInfo); };

  // ë”ë¸”í´ë¦­ â†’ foundation ìë™ ì´ë™
  d.ondblclick = (e) => {
    e.stopPropagation();
    const target = { type: 'foundation', suit: card.suit };
    if (canMoveToFoundation(card, target)) {
      selectedCard = card;
      selectedFrom = fromInfo;
      onFoundationClick(target);
    }
  };

  d.draggable = card.faceUp;
  d.ondragstart = (e) => { selectedCard = card; selectedFrom = fromInfo; e.dataTransfer.setData('text/plain', card.id); };

  d.setAttribute('data-card-id', card.id); // í„°ì¹˜ìš© ID

  return d;
}

//ì¹´ë“œ ë½‘ê¸°
function drawCard() {
  saveHistory();
  if (!stock.length) {
    if (!waste.length) return;

    while (waste.length) {
      const c = waste.pop();
      c.faceUp = false;
      stock.push(c);
    }
  } else {
    const c = stock.pop();
    c.faceUp = true;
    waste.push(c);
  }
  render();
}

let selectedCard = null;
let selectedFrom = null;

function valueNum(v) {
  return values.indexOf(v);
}

//ì¹´ë“œ ë†“ëŠ” ê·œì¹™
function canMove(card, from, to) {
  if (to.type === 'tableau') {
    const col = tableau[to.index];

    if (col.length === 0) return card.value === 'K';

    const top = col[col.length - 1];
    const diffColor =
      (['â™¥','â™¦'].includes(card.suit)) !==
      (['â™¥','â™¦'].includes(top.suit));

    return diffColor &&
      valueNum(card.value) === valueNum(top.value) - 1;
  }
  return false;
}

//ì¹´ë“œ ì„ íƒ
function onCardClick(card, from) {
  clearHints();
  if (!card.faceUp) return;

  // â­ ì›í´ë¦­ ìë™ ì´ë™ ì‹œë„
  if (!selectedCard) {
    const moved = autoMoveByOneClick(card, from);
    if (moved) return;   // ì´ë™í–ˆìœ¼ë©´ ì—¬ê¸°ì„œ ì¢…ë£Œ
  }
  
  // 1ï¸âƒ£ ì„ íƒ
  if (!selectedCard) {
    selectedCard = card;
    selectedFrom = from;
    render(); // â­ ì¤‘ìš”
    return;
  }

  // 2ï¸âƒ£ ê°™ì€ ì¹´ë“œ / ê°™ì€ ì»¬ëŸ¼ì´ë©´ ì·¨ì†Œ
  if (
    from.type === 'tableau' &&
    selectedFrom.type === 'tableau' &&
    from.index === selectedFrom.index
  ) {
    selectedCard = null;
    selectedFrom = null;
    render();
    return;
  }

  // 3ï¸âƒ£ ë‹¤ë¥¸ ì»¬ëŸ¼ ì¹´ë“œ í´ë¦­ â†’ ì´ë™ ì‹œë„
  if (from.type === 'tableau') {
    onPileClick({ type:'tableau', index: from.index });
  }
  
  // foundation ì¹´ë“œ í´ë¦­ ì‹œ ì´ë™ ì‹œë„
  if (from.type === 'foundation') {
    onFoundationClick({ type:'foundation', suit: from.suit });
  }
}

function onPileClick(to) {
  if (!selectedCard) return;  
  const stack = getMoveStack();
  if (canMove(stack[0], selectedFrom, to)) {
	saveHistory(); // â­ ì´ë™ ì „ì— ìƒíƒœ ì €ì¥
    // ğŸ”¹ ì¶œë°œì§€ ì œê±°
    if (selectedFrom.type === 'tableau') {
      const col = tableau[selectedFrom.index];
      col.splice(col.length - stack.length, stack.length);

      if (col.length && !col[col.length - 1].faceUp) {
        col[col.length - 1].faceUp = true;
      }
    }

    // ğŸ”¹ waste â†’ tableau (1ì¥)
    if (selectedFrom.type === 'waste') {
      waste.pop();
    }
	
	// â­ foundation â†’ tableau ì´ë™ ì²˜ë¦¬
    if (selectedFrom.type === 'foundation') {
      const pile = foundations[selectedFrom.suit];
      pile.pop();  // ë§ˆì§€ë§‰ ì¹´ë“œ ì œê±°
    }
	
    // ğŸ”¹ ëª©ì ì§€ì— ì—¬ëŸ¬ ì¥ ì¶”ê°€
    tableau[to.index].push(...stack);
	// â­ íŒíŠ¸ ì†Œë¹„ ì²˜ë¦¬
	markHintUsedIfMatched(stack[0], to);
	movedOnce = true;
  }

  selectedCard = null;
  selectedFrom = null;
  render();
}

//foundation ê·œì¹™ í•¨ìˆ˜
function canMoveToFoundation(card, to) {
  // â­ ë¬´ëŠ¬ ë¶ˆì¼ì¹˜ ë°©ì–´
  if (card.suit !== to.suit) return false;

  const f = foundations[to.suit];

  if (f.length === 0) return card.value === 'A';

  const order = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  return order.indexOf(card.value) ===
         order.indexOf(f[f.length - 1].value) + 1;
}


//foundation í´ë¦­ ì²˜ë¦¬
function onFoundationClick(to) {
  if (!selectedCard) return;

  if (canMoveToFoundation(selectedCard, to)) {

    // ğŸ”¹ ì¶œë°œì§€ ì œê±°
    if (selectedFrom.type === 'tableau') {
      const col = tableau[selectedFrom.index];
      col.pop();

      if (col.length && !col[col.length - 1].faceUp) {
        col[col.length - 1].faceUp = true;
      }
    }

    if (selectedFrom.type === 'waste') {
      waste.pop();
    }
	markHintUsedIfMatched(selectedCard, to);

    // ğŸ”¹ foundationì— ì¶”ê°€
    foundations[to.suit].push(selectedCard);
	movedOnce = true;
	checkWin();	
  }

  selectedCard = null;
  selectedFrom = null;
  render();  
}

//ì„ íƒ ì¹´ë“œ ìœ„ì¹˜ ì°¾ê¸°
function getMoveStack() {
  if (selectedFrom.type !== 'tableau') {
    return [selectedCard];
  }

  const col = tableau[selectedFrom.index];
  const idx = col.findIndex(c => c.id === selectedCard.id);

  return col.slice(idx);
}

function saveHistory() {
  // ê¹Šì€ ë³µì‚¬ í•„ìš” (deck, tableau, waste, foundations)
  const state = {
    tableau: tableau.map(col => col.map(c => ({...c}))),
    waste: waste.map(c => ({...c})),
    foundations: {
      'â™ ': foundations['â™ '].map(c => ({...c})),
      'â™¥': foundations['â™¥'].map(c => ({...c})),
      'â™¦': foundations['â™¦'].map(c => ({...c})),
      'â™£': foundations['â™£'].map(c => ({...c})),
    }
  };
  history.push({
        stock: stock.map(c=>({...c})),
        waste: waste.map(c=>({...c})),
        tableau: tableau.map(col=>col.map(c=>({...c}))),
        foundations: {
            'â™ ': [...foundations['â™ ']],
            'â™¥': [...foundations['â™¥']],
            'â™¦': [...foundations['â™¦']],
            'â™£': [...foundations['â™£']]
        }
    });
}

document.getElementById('undoBtn').onclick = () => {
    if(!history.length) return;
    const last = history.pop();
    stock = last.stock.map(c=>({...c}));
    waste = last.waste.map(c=>({...c}));
    tableau = last.tableau.map(col=>col.map(c=>({...c})));
    foundations = {
        'â™ ':[...last.foundations['â™ ']],
        'â™¥':[...last.foundations['â™¥']],
        'â™¦':[...last.foundations['â™¦']],
        'â™£':[...last.foundations['â™£']]
    };
    render();
};

function createUndoButton() {
  let btn = document.getElementById('undoBtn');
  if (!btn) {
    btn = document.createElement('button');
    btn.id = 'undoBtn';
    btn.textContent = 'â†©ï¸ ì‹¤í–‰ì·¨ì†Œ';
    btn.style.position = 'fixed';
    btn.style.bottom = '20px';
    btn.style.right = '20px';
    btn.style.zIndex = '1000';
    btn.style.padding = '10px 16px';
    btn.style.fontSize = '14px';
    btn.onclick = undoMove;
    document.body.appendChild(btn);
  }
}

function undoMove() {
  if (!history.length) return;

  const prev = history.pop();

  tableau = prev.tableau.map(col => col.map(c => ({...c})));
  waste = prev.waste.map(c => ({...c}));
  foundations = {
    'â™ ': prev.foundations['â™ '].map(c => ({...c})),
    'â™¥': prev.foundations['â™¥'].map(c => ({...c})),
    'â™¦': prev.foundations['â™¦'].map(c => ({...c})),
    'â™£': prev.foundations['â™£'].map(c => ({...c})),
  };

  selectedCard = null;
  selectedFrom = null;

  render();
}

//ìë™ ì´ë™
function autoMoveToFoundation(card, from) {
  if (!card.faceUp) return;

  const suit = card.suit;
  const to = { type:'foundation', suit };

  if (!canMoveToFoundation(card, to)) return;

  // ì¶œë°œì§€ ì œê±°
  if (from.type === 'tableau') {
    const col = tableau[from.index];
    col.pop();
    if (col.length && !col[col.length - 1].faceUp) {
      col[col.length - 1].faceUp = true;
    }
  }

  if (from.type === 'waste') {
    waste.pop();
  }

  foundations[suit].push(card); // âœ… í•­ìƒ ê°™ì€ ë¬´ëŠ¬
  movedOnce = true;
  selectedCard = null;
  selectedFrom = null;
  render();
}

function allCardsFaceUp() {
  return (
    stock.length === 0 && 
    tableau.flat().every(c => c.faceUp) &&
    waste.every(c => c.faceUp)
  );
}

function updateAutoCompleteButton() {
  const btn = document.getElementById('autoCompleteBtn');
  if (!btn) {
    return;
  }

  const available = isAutoCompleteAvailable();
 
  btn.style.display = available ? 'block' : 'none';
  btn.onclick = autoComplete;
}

// ëª¨ë“  ì¹´ë“œê°€ ì•ë©´ì¼ ë•Œë§Œ ë²„íŠ¼ ë³´ì´ê¸°
function checkAllFaceUp() {
    return tableau.flat().every(c=>c.faceUp) && waste.every(c=>c.faceUp);
}

//ìë™ ì™„ì„±
function autoComplete() {
  saveHistory();
  clearHints();
  let moved;
  do {
    moved = false;
    // 1ï¸âƒ£ tableau â†’ foundation
    tableau.forEach(col => {
      if (!col.length) return;

      const card = col[col.length - 1];
      const suit = card.suit;
      const target = { type: 'foundation', suit };

      if (canMoveToFoundation(card, target)) {
        col.pop();
        foundations[suit].push(card);
        moved = true;

        if (col.length && !col[col.length - 1].faceUp) {
          col[col.length - 1].faceUp = true;
        }
      }
    });

    // 2ï¸âƒ£ waste â†’ foundation
    if (waste.length) {
      const card = waste[waste.length - 1];
      const suit = card.suit;
      const target = { type: 'foundation', suit };

      if (canMoveToFoundation(card, target)) {
        waste.pop();
        foundations[suit].push(card);
        moved = true;
      }
    }

    render();
  } while (moved);

  checkWin();
}

//ìŠ¹ë¦¬ ì¡°ê±´
function checkWin() {
  const total =
    foundations['â™ '].length +
    foundations['â™¥'].length +
    foundations['â™¦'].length +
    foundations['â™£'].length;

  if (total === 52) {
    showWin();
  }
}

//ì¹´ë“œ í­ì£½
function cardFirework() {
  const cards = document.querySelectorAll('.card');

  cards.forEach(card => {
    const rect = card.getBoundingClientRect();

    // ğŸ”¥ body ê¸°ì¤€ìœ¼ë¡œ ì´ë™
    card.style.position = 'fixed';
    card.style.left = rect.left + 'px';
    card.style.top = rect.top + 'px';
    card.style.margin = '0';
    card.style.zIndex = '9999';

    document.body.appendChild(card);

    const x = (Math.random() - 0.5) * window.innerWidth;
    const y = -window.innerHeight - Math.random() * 300;
    const r = Math.random() * 720 - 360;

    requestAnimationFrame(() => {
      card.style.transition = 'transform 1.3s ease-out, opacity 1.3s';
      card.style.transform = `translate(${x}px, ${y}px) rotate(${r}deg)`;
      card.style.opacity = '0';
    });
  });
}

//ìŠ¹ë¦¬ í‘œì‹œ
function showWin() {
  stopTimer();            // íƒ€ì´ë¨¸ ì •ì§€
  cardFirework();         // ì¹´ë“œ í­ì£½

  const elapsed = Date.now() - startTime;
  const totalSec = Math.floor(elapsed / 1000);
  const min = Math.floor(totalSec / 60);
  const sec = totalSec % 60;

  document.getElementById('winTime').textContent =
    `í´ë¦¬ì–´ ì‹œê°„: ${min}ë¶„ ${sec}ì´ˆ`;

  const o = document.getElementById('winOverlay');
  o.style.display = 'flex';

  document.body.style.pointerEvents = 'none';
  o.style.pointerEvents = 'auto';
}

//í…ŒìŠ¤íŠ¸
function forceWin() {
  // ëª¨ë“  ì¹´ë“œ ìˆ˜ì§‘
  const allCards = [
    ...stock,
    ...waste,
    ...tableau.flat(),
    ...foundations['â™ '],
    ...foundations['â™¥'],
    ...foundations['â™¦'],
    ...foundations['â™£']
  ];

  // ì´ˆê¸°í™”
  stock = [];
  waste = [];
  tableau = [[],[],[],[],[],[],[]];
  foundations = { 'â™ ':[], 'â™¥':[], 'â™¦':[], 'â™£':[] };

  // foundationì— ì •ë ¬í•´ì„œ ë„£ê¸°
  allCards.forEach(c => {
    c.faceUp = true;
    foundations[c.suit].push(c);
  });

  render();
  checkWin();
}


// ëª¨ë°”ì¼ í„°ì¹˜ìš© ì¹´ë“œ ì´ë™
let touchStartCard = null;
let touchStartFrom = null;
let touchStartY = 0;
let touchStartX = 0;

document.addEventListener('touchstart', e => {
    const el = e.target.closest('.card');
    if (!el) return;
	e.preventDefault(); // ì¹´ë“œ í„°ì¹˜ì¼ ë•Œë§Œ

    const id = parseInt(el.getAttribute('data-card-id'));
    touchStartCard = findCardById(id);
    touchStartFrom = findCardFrom(touchStartCard);

    touchStartY = e.touches[0].clientY;
    touchStartX = e.touches[0].clientX;

    e.preventDefault();
});

document.addEventListener('touchmove', e => {
    if (!touchStartCard) return;
    const moveY = e.touches[0].clientY - touchStartY;
    const moveX = e.touches[0].clientX - touchStartX;
    const el = document.querySelector(`.card[data-card-id='${touchStartCard.id}']`);
    el.style.transform = `translate(${moveX}px, ${moveY}px)`;
});

document.addEventListener('touchend', e => {
    if (!touchStartCard) return;

    const el = document.querySelector(
      `.card[data-card-id='${touchStartCard.id}']`
    );
    el.style.transform = '';

    const touch = e.changedTouches[0];
    const targetEl = document.elementFromPoint(touch.clientX, touch.clientY);
    let targetPile = targetEl?.closest('.pile');

    // =============================
    // â­ 1ï¸âƒ£ foundation ìœ„ì— ë“œë¡­
    // =============================
    if (targetPile?.classList.contains('foundation')) {
        selectedCard = touchStartCard;
        selectedFrom = touchStartFrom;
        onFoundationClick({
            type: 'foundation',
            suit: targetPile.dataset.suit
        });
    }

    // =============================
    // â­ 2ï¸âƒ£ tableau ìœ„ì— ë“œë¡­
    // =============================
    else if (targetPile?.parentElement?.id === 'tableau') {
        selectedCard = touchStartCard;
        selectedFrom = touchStartFrom;
        onPileClick({
            type: 'tableau',
            index: Array.from(
              document.querySelectorAll('#tableau .pile')
            ).indexOf(targetPile)
        });
    }

    // =============================
    // â­ 3ï¸âƒ£ ê·¸ëƒ¥ íƒ­ â†’ foundation ìë™ ì´ë™
    // =============================
    else {
        if (!movedOnce) {
		  autoMoveToFoundation(touchStartCard, touchStartFrom);
		}
    }
    touchStartCard = null;
    touchStartFrom = null;
	movedOnce = false;
});

// í—¬í¼: ì¹´ë“œ ID â†’ ì¹´ë“œ ê°ì²´
function findCardById(id) {
    for (let col of tableau) {
        for (let c of col) if (c.id === id) return c;
    }
    for (let c of waste) if (c.id === id) return c;
    for (let s of suits) {
        for (let c of foundations[s]) if (c.id === id) return c;
    }
    for (let c of stock) if (c.id === id) return c;
    return null;
}

// í—¬í¼: ì¹´ë“œ ê°ì²´ â†’ fromInfo
function findCardFrom(card) {
    for (let i=0;i<tableau.length;i++) if (tableau[i].includes(card)) return { type:'tableau', index:i };
    if (waste.includes(card)) return { type:'waste' };
    for (let s of suits) if (foundations[s].includes(card)) return { type:'foundation', suit:s };
    return null;
}

document.getElementById('testAutoBtn').onclick = () => {
  forceAutoCompleteTest();
};

function forceAutoCompleteTest() {
  // ì „ì²´ ì¹´ë“œ ìˆ˜ì§‘
  const all = [
    ...stock,
    ...waste,
    ...tableau.flat(),
    ...Object.values(foundations).flat()
  ];

  // ì´ˆê¸°í™”
  stock = [];
  waste = [];
  tableau = [[], [], [], [], [], [], []];
  foundations = { 'â™ ': [], 'â™¥': [], 'â™¦': [], 'â™£': [] };

  // value ì •ë ¬ìš©
  const order = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

  // ìŠˆíŠ¸ë³„ ë¶„ë¦¬
  const bySuit = { 'â™ ':[], 'â™¥':[], 'â™¦':[], 'â™£':[] };
  all.forEach(c => {
    c.faceUp = true;
    bySuit[c.suit].push(c);
  });

  // foundationì— A~Q ìˆœì„œë¡œ ë„£ê¸°
  Object.keys(bySuit).forEach(suit => {
    bySuit[suit]
      .sort((a,b) => order.indexOf(a.value) - order.indexOf(b.value))
      .forEach(card => {
        if (card.value !== 'K') {
          foundations[suit].push(card);
        }
      });
  });

  // KëŠ” tableauì— í•˜ë‚˜ì”©
  Object.keys(bySuit).forEach((suit, i) => {
    const king = bySuit[suit].find(c => c.value === 'K');
    if (king) tableau[i].push(king);
  });

  render();
  updateAutoCompleteButton();
}

function isAutoCompleteAvailable() {
  if (stock.length > 0) {
    return false;
  }

  if (waste.length > 0) {
    return false;
  }

  // tableau ëª¨ë“  ì¹´ë“œ ì•ë©´ í™•ì¸
  for (let i = 0; i < tableau.length; i++) {
    for (let j = 0; j < tableau[i].length; j++) {
      if (!tableau[i][j].faceUp) {
        return false;
      }
    }
  }
  return true;
}

//ìë™ ëª©ì ì§€ ì°¾ê¸°
function autoMoveByOneClick(card, from) {
  if (!card.faceUp) return false;

  // ğŸ”¹ 1. foundation ìš°ì„ 
  const fTarget = { type:'foundation', suit: card.suit };
  if (canMoveToFoundation(card, fTarget)) {
    saveHistory();
    selectedCard = card;
    selectedFrom = from;
    onFoundationClick(fTarget);
    return true;
  }

  // ğŸ”¹ 2. tableau íƒìƒ‰
  for (let i = 0; i < tableau.length; i++) {
    const to = { type:'tableau', index: i };
    if (canMove(card, from, to)) {
      saveHistory();
      selectedCard = card;
      selectedFrom = from;
      onPileClick(to);
      return true;
    }
  }

  return false;
}

//ì´ì „ì— í‘œì‹œëœ ëª¨ë“  íŒíŠ¸ ê°•ì¡° ì œê±°
function clearHints() {
  document.querySelectorAll('.hint').forEach(el => {
    el.classList.remove('hint');
  });
}

//ì „ì—­ íŒíŠ¸ ë¡œì§
function showGlobalHint() {
  clearHints();

  const available = collectAllHints()
    .filter(h => !usedHints.has(hintKey(h)));

	if (!available.length) {
		const stockEl = document.getElementById('stock');

		if (stock.length || waste.length) {
		clearHintOverlay();
		showHintOverlay(stockEl); // â­ï¸ ì—¬ê¸°!
		}

		currentHint = null;
		return;
	}

  currentHint = available[hintIndex % available.length];
  hintIndex++;

  const card = findCardById(currentHint.cardId);
  highlightMove(card, currentHint.from, currentHint.to);  
}

//íŒíŠ¸ì¼ ë•Œë§Œ ê¸°ë¡
function markHintUsedIfMatched(card, to) {
  if (!currentHint) return;

  if (
    card.id === currentHint.cardId &&
    JSON.stringify(to) === JSON.stringify(currentHint.to)
  ) {
    usedHints.add(hintKey(currentHint));
    currentHint = null;
  }
}

// ì´ë™ ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸
function highlightMove(card, from, to) {
  clearHintOverlay();

  // ğŸ”¹ ì´ë™ ì¹´ë“œ
  const cardEl = document.querySelector(
    `.card[data-card-id='${card.id}']`
  );
  if (cardEl) showHintOverlay(cardEl);

  // ğŸ”¹ ëª©ì ì§€
  if (to.type === 'foundation') {
    const f = document.querySelector(
      `.foundation[data-suit='${to.suit}']`
    );
    showHintOverlay(f.querySelector('.card:last-child') || f);
  }

  if (to.type === 'tableau') {
    const col = tableau[to.index];
    if (col.length) {
      const top = document.querySelector(
        `.card[data-card-id='${col[col.length - 1].id}']`
      );
      showHintOverlay(top);
    } else {
      showHintOverlay(
        document.querySelectorAll('#tableau .pile')[to.index]
      );
    }
  }
}


//ëª¨ë“  íŒíŠ¸ ìˆ˜ì§‘ í•¨ìˆ˜
function collectAllHints() {
  const hints = [];

  // tableau â†’ tableau / foundation
  for (let i = 0; i < tableau.length; i++) {
    const col = tableau[i];
    if (!col.length) continue;

    const card = col[col.length - 1];
    const from = { type:'tableau', index:i };

    // foundation
    if (canMoveToFoundation(card, { type:'foundation', suit:card.suit })) {
      hints.push({ cardId: card.id, from, to:{ type:'foundation', suit:card.suit } });
    }

    // tableau
    for (let j = 0; j < tableau.length; j++) {
      if (i === j) continue;
      const to = { type:'tableau', index:j };
      if (canMove(card, from, to)) {
        hints.push({ cardId: card.id, from, to });
      }
    }
  }

  // waste â†’ tableau / foundation
  if (waste.length) {
    const card = waste[waste.length - 1];
    const from = { type:'waste' };

    if (canMoveToFoundation(card, { type:'foundation', suit:card.suit })) {
      hints.push({ cardId: card.id, from, to:{ type:'foundation', suit:card.suit } });
    }

    for (let i = 0; i < tableau.length; i++) {
      const to = { type:'tableau', index:i };
      if (canMove(card, from, to)) {
        hints.push({ cardId: card.id, from, to });
      }
    }
  }

  return hints;
}

//íŒíŠ¸ ê³ ìœ  í‚¤ ë§Œë“¤ê¸°
function hintKey(hint) {
  return `${hint.cardId}->${JSON.stringify(hint.to)}`;
}

//ì´ë™ ì„±ê³µ ì‹œ íŒíŠ¸ ê¸°ë¡
function markHintUsed(card, to) {
  usedHints.add(`${card.id}->${JSON.stringify(to)}`);
}

//íŒíŠ¸ ìƒíƒœ ì´ˆê¸°í™”
function resetHints() {
  hintList = [];
  hintIndex = 0;
}

function showHintOverlay(el) {
  const rect = el.getBoundingClientRect();

  const h = document.createElement('div');
  h.className = 'hint';
  h.style.position = 'fixed';
  h.style.left = rect.left + 'px';
  h.style.top = rect.top + 'px';
  h.style.width = rect.width + 'px';
  h.style.height = rect.height + 'px';
  h.style.pointerEvents = 'none';

  document.getElementById('hintOverlay').appendChild(h);
}

function clearHintOverlay() {
  document.getElementById('hintOverlay').innerHTML = '';
}

document.getElementById('hintBtn').onclick = showGlobalHint;

startGame();
</script>
</body>
</html>
