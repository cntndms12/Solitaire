<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Solitaire (Klondike)</title>
  <style>
	:root {
	  --card-w: clamp(72px, 14vw, 120px);
	  --card-h: calc(var(--card-w) * 1.4);
	  --card-gap: clamp(6px, 2vw, 12px);
	  
	  --tableau-w: calc(
		(var(--card-w) * 7) + var(--card-gap) * 6)
	  );
	}
    body { background:#0b6623; color:#fff; font-family:sans-serif; 
		   overscroll-behavior: none; max-width: 100vw; overflow-x: hidden;}
    .board { display:flex; flex-direction:column; gap:20px; padding:20px; width:40%;}
    .row { display:flex; gap:12px; }
	#top {
	  display: grid;
	  grid-template-columns: repeat(7, var(--card-w));
	  gap: var(--card-gap);
	  width: fit-content;
	}
	#tableau {
	  display: grid;
	  grid-template-columns: repeat(7, var(--card-w));
	  gap: var(--card-gap);
	}
	#actionBarTop {
	  width: var(--tableau-w);
	  display: flex;
	  justify-content: space-between;
	  margin-top: 12px;
	  Padding-left: 20px;
	  Padding-right: 20px;	  
	}
	#actionBarTop button {
	  padding: 10px 10px;
	  font-size: 20px;
	}
	#leftBtn{
	  justify-content: space-between;
	  lefe: 10px;	  
	}
	#actionBarBottom {
	  position: fixed;
	  bottom: 20px;
	  left: 20px;
	  width: 655px;              /* PC ê¸°ì¤€ tableau í­ */
	  display: flex;
	  z-index: 1000;
	}
	#actionBarBottom button {
	  padding: 10px 16px;
	  font-size: 14px;
	}
    .pile {
	  width: var(--card-w);
	  min-height: var(--card-h);
	  border:1px solid rgba(255,255,255,0.3);
	  border-radius:6px;
	  position:relative;
	}
    .card {
	  width: var(--card-w);
      height: var(--card-h);
	  border-radius:6px;
	  background:#fff;
	  position:absolute;
	  cursor:pointer;
	  outline: 1px solid black;
	  cursor: grab;
	}
	.card:active {
	  cursor: grabbing;
	}
	.card .label {
	  position: absolute;
	  top: 8px;
	  left: 8px;
	  font-size: clamp(16px, 4vw, 22px);
	  font-weight: 800;
	  line-height: 1;
	  text-shadow: 0 1px 0 rgba(255,255,255,0.6);
	}	
	.red { color: #c60000; }
	.black { color: #111; }
    .center-suit {
	  position: absolute;
	  inset: 0;
	  display: flex;
	  align-items: center;
	  justify-content: center;

	  font-size: clamp(44px, 14vw, 72px);
	  opacity: 0.95;
	  font-weight: 900;
	  pointer-events: none;
	  user-select: none;	  
	}
	.center-suit.red {
	  color: rgb(200, 0, 40);   /* ì§„í•œ ë ˆë“œ */
	}
	.center-suit.black {
	  color: rgb(10, 10, 10);   /* ê±°ì˜ ë¸”ë™ */
	}
	.back {
	  background: repeating-linear-gradient(
		45deg,
		#1e90ff,
		#1e90ff 10px,
		#1565c0 10px,
		#1565c0 20px
	  );
	}
	
	.selected {
	  outline: 3px solid gold;
	  outline-offset: -3px;
	}
	
	@keyframes firework {
	  0% {
		transform: translate(0,0) rotate(0deg);
		opacity: 1;
	  }
	  100% {
		transform:
		  translate(
			calc((Math.random() - 0.5) * 600px),
			-600px
		  )
		  rotate(720deg);
		opacity: 0;
	  }
	}

	.firework {
	  animation: firework 1.2s ease-out forwards;
	}
	
	/* ëª¨ë°”ì¼ ëŒ€ì‘ ì˜ˆì‹œ */
	@media (max-width: 600px) {
	  :root {
		--card-w: 104px;
		--card-h: 148px;
		--card-gap: 6px;
	  }
	  body {font-size: 16px;}
	  /* í•˜ë‹¨ ë²„íŠ¼ ë°” */
	  #actionBarBottom {
		width: calc(100% - 24px); /* í™”ë©´ ì–‘ìª½ ì—¬ë°± */
		bottom: calc(16px + env(safe-area-inset-bottom));
	  }

	  #actionBarBottom button {
		width: 100%;
		padding: 18px 0;
		font-size: 18px;
		border-radius: 12px;
	  }

	  /* ìƒë‹¨ action barë„ ëª¨ë°”ì¼ ì •ë ¬ */
	  #actionBarTop {
		width: 100%;
		flex-direction: column;
		gap: 12px;
	  }

	  #leftBtn {
		display: flex;
		gap: 8px;
	  }

	  #leftBtn button,
	  #autoCompleteBtn {
		flex: 1;
	  }
	  .pile {
		width:100px;
		min-height:140px;
	  }
	  .card {
		width:100px;
		height:140px;
	  }
	  .card .label {
		font-size:16px;
	  }

	  #undoBtn, #refreshBtn, #autoCompleteBtn {
		padding:16px 20px;
		font-size:18px;
	  }
	}	
  </style>
</head>
<body>
  <h1>ğŸƒ ì†”ë¦¬í…Œì–´ (í´ë¡ ë‹¤ì´í¬)</h1>
	<div id ="actionBarTop">
		<div id = "leftBtn">
		  <button id="refreshBtn">ğŸ”„ìƒˆë¡œê³ ì¹¨ğŸ”„</button>
		  <button id="undoBtn">â†©ï¸ì‹¤í–‰ì·¨ì†Œï¸â†©ï¸</button>
		</div>
	  <button id="autoCompleteBtn">ğŸ†ìë™ì™„ì„±ğŸ†</button>
	</div>
	
  <div class="board">	
    <div class="row" id="top">
	  <div class="pile" id="stock" style="grid-column:1"></div>
	  <div class="pile" id="waste" style="grid-column:2"></div>

	  <div class="pile foundation" data-suit="â™ " style="grid-column:4"></div>
	  <div class="pile foundation" data-suit="â™¥" style="grid-column:5"></div>
	  <div class="pile foundation" data-suit="â™¦" style="grid-column:6"></div>
	  <div class="pile foundation" data-suit="â™£" style="grid-column:7"></div>
	</div>	
    <div class="row" id="tableau"></div>
	
	<div id="actionBarBottom">
		<button id="testAutoBtn">ğŸ†ìë™ì™„ì„±í…ŒìŠ¤íŠ¸</button>
	</div>

  <!-- ìŠ¹ë¦¬ ì˜¤ë²„ë ˆì´ UI -->
  <div id="winOverlay" style="
	  display:none;
	  position:fixed;
	  inset:0;
	  background:rgba(0,0,0,0.6);
	  z-index:999;
	  color:#fff;
	  font-size:48px;
	  font-weight:bold;
	  align-items:center;
	  justify-content:center;
	  flex-direction:column;
	">
	  ğŸ‰ CLEAR!
	  <button onclick="location.reload()" style="
		margin-top:20px;
		font-size:18px;
		padding:10px 20px;
		cursor:pointer;
	  ">ë‹¤ì‹œí•˜ê¸°</button>
	</div>
<script>
const suits = ['â™ ','â™¥','â™¦','â™£'];
const values = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
let deck = [];
let stock = [], waste = [];
let tableau = [[],[],[],[],[],[],[]];
let history = []; // ì „ì²´ ìƒíƒœ ì €ì¥ìš©
let cardId = 0;
let foundations = {
  'â™ ': [],
  'â™¥': [],
  'â™¦': [],
  'â™£': []
};

document.getElementById('refreshBtn').onclick = () => {
    location.reload();
};

//ë± ìƒì„±
function createDeck() {
  deck = [];
  for (let s of suits) {
    for (let v of values) {
      deck.push({
        id: cardId++,   // â­ ê³ ìœ  ID
        suit: s,
        value: v,
        faceUp: false
      });
    }
  }
  deck.sort(() => Math.random() - 0.5);
}

//ì¹´ë“œë°°ì¹˜
function deal() {
  for (let i=0;i<7;i++) {
    for (let j=0;j<=i;j++) {
      const card = deck.pop();
      if (j === i) card.faceUp = true;
      tableau[i].push(card);
    }
  }
  stock = deck;
}

function render() {
  document.getElementById('stock').innerHTML = '';
  document.getElementById('waste').innerHTML = '';

  // stock
  if (stock.length || waste.length) {
	  const c = document.createElement('div');
	  c.className = 'card back';
	  c.onclick = drawCard;
	  document.getElementById('stock').appendChild(c);
	}

  // waste
  if (waste.length) {
    const card = waste[waste.length-1];
    document.getElementById('waste')
      .appendChild(cardEl(card, {type:'waste'}));
  }

  /* =====================
     tableau ë Œë”
     ===================== */
  const tab = document.getElementById('tableau');
  tab.innerHTML = '';

  tableau.forEach((col, colIdx) => {
	  const p = document.createElement('div');
	  p.className = 'pile';

	  let topOffset = 0; // â­â­â­ ì—¬ê¸°! ì»¬ëŸ¼ë§ˆë‹¤ ì´ˆê¸°í™”

	  p.onclick = (e) => {
		if (e.target !== p) return;
		onPileClick({ type:'tableau', index:colIdx });
	  };
	    // ğŸ”½ ë“œë˜ê·¸ í—ˆìš© (í•„ìˆ˜)
	  p.ondragover = (e) => {
		e.preventDefault(); // ì´ê±° ì—†ìœ¼ë©´ drop ì•ˆë¨
	  };

	  // ğŸ”½ ë“œë¡­ ì‹œ ì´ë™
	  p.ondrop = (e) => {
		e.preventDefault();
		onPileClick({ type:'tableau', index:colIdx });
	  };

	  col.forEach((card) => {
		const el = cardEl(card, { type:'tableau', index:colIdx });

		if (!card.faceUp) {
		  el.style.top = topOffset + 'px';
		  topOffset += 20;   // ë’¤ì§‘íŒ ì¹´ë“œ
		} else {
		  el.style.top = topOffset + 'px';
		  topOffset += 30;   // í¼ì³ì§„ ì¹´ë“œ
		}

		p.appendChild(el);
	  });

	  tab.appendChild(p);
	});

  /* =====================
     foundation ë Œë”
     ===================== */
  document.querySelectorAll('.foundation').forEach(f => {
	  const suit = f.dataset.suit;
	  f.innerHTML = '';

	  const pile = foundations[suit];

	  if (pile.length) {
		const card = pile[pile.length - 1];
		f.appendChild(cardEl(card, { type:'foundation', suit }));
	  } else {
		// â­ ë¬´ëŠ¬ í‘œì‹œ
		const hint = document.createElement('div');
		hint.style.position = 'absolute';
		hint.style.inset = '0';
		hint.style.display = 'flex';
		hint.style.alignItems = 'center';
		hint.style.justifyContent = 'center';
		hint.style.fontSize = '60px';
		hint.style.opacity = '0.3';
		hint.textContent = suit;
		f.appendChild(hint);
	  }

	  f.onclick = () =>
		onFoundationClick({ type:'foundation', suit });
	});
	
	// ë§ˆì§€ë§‰ì— ë²„íŠ¼ ìƒíƒœ ê°±ì‹ 
	updateAutoCompleteButton();
	createUndoButton(); // í•­ìƒ ë²„íŠ¼ ìƒì„±
}

//ì¹´ë“œ ë§Œë“¤ê¸°
function cardEl(card, fromInfo) {
	
  const d = document.createElement('div');
  d.className = 'card ' + ((card.suit==='â™¥'||card.suit==='â™¦') ? 'red' : 'black');

  if (!card.faceUp) d.classList.add('back');

  if (card.faceUp) {
    // ì¢Œìƒë‹¨ ìˆ«ì + ë¬´ëŠ¬
    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = card.value + card.suit;
    d.appendChild(label);

    // ì¤‘ì•™ í° ë¬´ëŠ¬
    const center = document.createElement('div');
    center.className = 'center-suit';
    center.textContent = card.suit;
    d.appendChild(center);
  }

  // ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸
  d.onclick = (e) => { e.stopPropagation(); onCardClick(card, fromInfo); };

  // ë”ë¸”í´ë¦­ â†’ foundation ìë™ ì´ë™
  d.ondblclick = (e) => {
    e.stopPropagation();
    const target = { type: 'foundation', suit: card.suit };
    if (canMoveToFoundation(card, target)) {
      selectedCard = card;
      selectedFrom = fromInfo;
      onFoundationClick(target);
    }
  };

  d.draggable = card.faceUp;
  d.ondragstart = (e) => { selectedCard = card; selectedFrom = fromInfo; e.dataTransfer.setData('text/plain', card.id); };

  // ì¹´ë“œ ì„ íƒ í‘œì‹œ
  if (selectedCard && selectedCard.id === card.id) d.classList.add('selected');

  d.setAttribute('data-card-id', card.id); // í„°ì¹˜ìš© ID

  return d;
}

//ì¹´ë“œ ë½‘ê¸°
function drawCard() {
  saveHistory();
  if (!stock.length) {
    if (!waste.length) return;

    while (waste.length) {
      const c = waste.pop();
      c.faceUp = false;
      stock.push(c);
    }
  } else {
    const c = stock.pop();
    c.faceUp = true;
    waste.push(c);
  }
  render();
}

let selectedCard = null;
let selectedFrom = null;

function valueNum(v) {
  return values.indexOf(v);
}

//ì¹´ë“œ ë†“ëŠ” ê·œì¹™
function canMove(card, from, to) {
  if (to.type === 'tableau') {
    const col = tableau[to.index];

    if (col.length === 0) return card.value === 'K';

    const top = col[col.length - 1];
    const diffColor =
      (['â™¥','â™¦'].includes(card.suit)) !==
      (['â™¥','â™¦'].includes(top.suit));

    return diffColor &&
      valueNum(card.value) === valueNum(top.value) - 1;
  }
  return false;
}

//ì¹´ë“œ ì„ íƒ
function onCardClick(card, from) {
  if (!card.faceUp) return;

  // 1ï¸âƒ£ ì„ íƒ
  if (!selectedCard) {
    selectedCard = card;
    selectedFrom = from;
    render(); // â­ ì¤‘ìš”
    return;
  }

  // 2ï¸âƒ£ ê°™ì€ ì¹´ë“œ / ê°™ì€ ì»¬ëŸ¼ì´ë©´ ì·¨ì†Œ
  if (
    from.type === 'tableau' &&
    selectedFrom.type === 'tableau' &&
    from.index === selectedFrom.index
  ) {
    selectedCard = null;
    selectedFrom = null;
    render();
    return;
  }

  // 3ï¸âƒ£ ë‹¤ë¥¸ ì»¬ëŸ¼ ì¹´ë“œ í´ë¦­ â†’ ì´ë™ ì‹œë„
  if (from.type === 'tableau') {
    onPileClick({ type:'tableau', index: from.index });
  }
  
  // foundation ì¹´ë“œ í´ë¦­ ì‹œ ì´ë™ ì‹œë„
  if (from.type === 'foundation') {
    onFoundationClick({ type:'foundation', suit: from.suit });
  }
}

function onPileClick(to) {
  if (!selectedCard) return;  
  const stack = getMoveStack();
  if (canMove(stack[0], selectedFrom, to)) {
	saveHistory(); // â­ ì´ë™ ì „ì— ìƒíƒœ ì €ì¥
    // ğŸ”¹ ì¶œë°œì§€ ì œê±°
    if (selectedFrom.type === 'tableau') {
      const col = tableau[selectedFrom.index];
      col.splice(col.length - stack.length, stack.length);

      if (col.length && !col[col.length - 1].faceUp) {
        col[col.length - 1].faceUp = true;
      }
    }

    // ğŸ”¹ waste â†’ tableau (1ì¥)
    if (selectedFrom.type === 'waste') {
      waste.pop();
    }
	
	// â­ foundation â†’ tableau ì´ë™ ì²˜ë¦¬
    if (selectedFrom.type === 'foundation') {
      const pile = foundations[selectedFrom.suit];
      pile.pop();  // ë§ˆì§€ë§‰ ì¹´ë“œ ì œê±°
    }
	
    // ğŸ”¹ ëª©ì ì§€ì— ì—¬ëŸ¬ ì¥ ì¶”ê°€
    tableau[to.index].push(...stack);
  }

  selectedCard = null;
  selectedFrom = null;
  render();
}

//foundation ê·œì¹™ í•¨ìˆ˜
function canMoveToFoundation(card, to) {
  saveHistory();
  const f = foundations[card.suit];

  if (f.length === 0) return card.value === 'A';

  const order = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  return order.indexOf(card.value) === order.indexOf(f[f.length - 1].value) + 1;
}

//foundation í´ë¦­ ì²˜ë¦¬
function onFoundationClick(to) {
  if (!selectedCard) return;

  if (canMoveToFoundation(selectedCard, to)) {

    // ğŸ”¹ ì¶œë°œì§€ ì œê±°
    if (selectedFrom.type === 'tableau') {
      const col = tableau[selectedFrom.index];
      col.pop();

      if (col.length && !col[col.length - 1].faceUp) {
        col[col.length - 1].faceUp = true;
      }
    }

    if (selectedFrom.type === 'waste') {
      waste.pop();
    }

    // ğŸ”¹ foundationì— ì¶”ê°€
    foundations[to.suit].push(selectedCard);
	checkWin();
  }

  selectedCard = null;
  selectedFrom = null;
  render();  
}

//ì„ íƒ ì¹´ë“œ ìœ„ì¹˜ ì°¾ê¸°
function getMoveStack() {
  if (selectedFrom.type !== 'tableau') {
    return [selectedCard];
  }

  const col = tableau[selectedFrom.index];
  const idx = col.findIndex(c => c.id === selectedCard.id);

  return col.slice(idx);
}

function saveHistory() {
  // ê¹Šì€ ë³µì‚¬ í•„ìš” (deck, tableau, waste, foundations)
  const state = {
    tableau: tableau.map(col => col.map(c => ({...c}))),
    waste: waste.map(c => ({...c})),
    foundations: {
      'â™ ': foundations['â™ '].map(c => ({...c})),
      'â™¥': foundations['â™¥'].map(c => ({...c})),
      'â™¦': foundations['â™¦'].map(c => ({...c})),
      'â™£': foundations['â™£'].map(c => ({...c})),
    }
  };
  history.push({
        stock: stock.map(c=>({...c})),
        waste: waste.map(c=>({...c})),
        tableau: tableau.map(col=>col.map(c=>({...c}))),
        foundations: {
            'â™ ': [...foundations['â™ ']],
            'â™¥': [...foundations['â™¥']],
            'â™¦': [...foundations['â™¦']],
            'â™£': [...foundations['â™£']]
        }
    });
}

document.getElementById('undoBtn').onclick = () => {
    if(!history.length) return;
    const last = history.pop();
    stock = last.stock.map(c=>({...c}));
    waste = last.waste.map(c=>({...c}));
    tableau = last.tableau.map(col=>col.map(c=>({...c})));
    foundations = {
        'â™ ':[...last.foundations['â™ ']],
        'â™¥':[...last.foundations['â™¥']],
        'â™¦':[...last.foundations['â™¦']],
        'â™£':[...last.foundations['â™£']]
    };
    render();
};

function createUndoButton() {
  let btn = document.getElementById('undoBtn');
  if (!btn) {
    btn = document.createElement('button');
    btn.id = 'undoBtn';
    btn.textContent = 'â†©ï¸ ì‹¤í–‰ì·¨ì†Œ';
    btn.style.position = 'fixed';
    btn.style.bottom = '20px';
    btn.style.right = '20px';
    btn.style.zIndex = '1000';
    btn.style.padding = '10px 16px';
    btn.style.fontSize = '14px';
    btn.onclick = undoMove;
    document.body.appendChild(btn);
  }
}

function undoMove() {
  if (!history.length) return;

  const prev = history.pop();

  tableau = prev.tableau.map(col => col.map(c => ({...c})));
  waste = prev.waste.map(c => ({...c}));
  foundations = {
    'â™ ': prev.foundations['â™ '].map(c => ({...c})),
    'â™¥': prev.foundations['â™¥'].map(c => ({...c})),
    'â™¦': prev.foundations['â™¦'].map(c => ({...c})),
    'â™£': prev.foundations['â™£'].map(c => ({...c})),
  };

  selectedCard = null;
  selectedFrom = null;

  render();
}

//ìë™ ì´ë™
function autoMoveToFoundation(card, from) {
  if (!card.faceUp) return;

  for (let suit of suits) {
    const to = { type:'foundation', suit };

    if (canMoveToFoundation(card, to)) {

      // ì¶œë°œì§€ ì œê±°
      if (from.type === 'tableau') {
        const col = tableau[from.index];
        col.pop();

        if (col.length && !col[col.length - 1].faceUp) {
          col[col.length - 1].faceUp = true;
        }
      }

      if (from.type === 'waste') {
        waste.pop();
      }

      foundations[suit].push(card);
      selectedCard = null;
      selectedFrom = null;
      render();
      return;
    }
  }
}

function allCardsFaceUp() {
  return (
    stock.length === 0 && 
    tableau.flat().every(c => c.faceUp) &&
    waste.every(c => c.faceUp)
  );
}

function updateAutoCompleteButton() {
  const btn = document.getElementById('autoCompleteBtn');
  if (!btn) {
    return;
  }

  const available = isAutoCompleteAvailable();
 
  btn.style.display = available ? 'block' : 'none';
  btn.onclick = autoComplete;
}

// ëª¨ë“  ì¹´ë“œê°€ ì•ë©´ì¼ ë•Œë§Œ ë²„íŠ¼ ë³´ì´ê¸°
function checkAllFaceUp() {
    return tableau.flat().every(c=>c.faceUp) && waste.every(c=>c.faceUp);
}

//ìë™ ì™„ì„±
function autoComplete() {
  saveHistory();
  let moved;
  do {
    moved = false;
    // 1ï¸âƒ£ tableau â†’ foundation
    tableau.forEach(col => {
      if (!col.length) return;

      const card = col[col.length - 1];
      const suit = card.suit;
      const target = { type: 'foundation', suit };

      if (canMoveToFoundation(card, target)) {
        col.pop();
        foundations[suit].push(card);
        moved = true;

        if (col.length && !col[col.length - 1].faceUp) {
          col[col.length - 1].faceUp = true;
        }
      }
    });

    // 2ï¸âƒ£ waste â†’ foundation
    if (waste.length) {
      const card = waste[waste.length - 1];
      const suit = card.suit;
      const target = { type: 'foundation', suit };

      if (canMoveToFoundation(card, target)) {
        waste.pop();
        foundations[suit].push(card);
        moved = true;
      }
    }

    render();
  } while (moved);

  checkWin();
}

//ìŠ¹ë¦¬ ì¡°ê±´
function checkWin() {
  const total =
    foundations['â™ '].length +
    foundations['â™¥'].length +
    foundations['â™¦'].length +
    foundations['â™£'].length;

  if (total === 52) {
    showWin();
  }
}

//ì¹´ë“œ í­ì£½
function cardFirework() {
  const cards = document.querySelectorAll('.card');

  cards.forEach(card => {
    const rect = card.getBoundingClientRect();

    // ğŸ”¥ body ê¸°ì¤€ìœ¼ë¡œ ì´ë™
    card.style.position = 'fixed';
    card.style.left = rect.left + 'px';
    card.style.top = rect.top + 'px';
    card.style.margin = '0';
    card.style.zIndex = '9999';

    document.body.appendChild(card);

    const x = (Math.random() - 0.5) * window.innerWidth;
    const y = -window.innerHeight - Math.random() * 300;
    const r = Math.random() * 720 - 360;

    requestAnimationFrame(() => {
      card.style.transition = 'transform 1.3s ease-out, opacity 1.3s';
      card.style.transform = `translate(${x}px, ${y}px) rotate(${r}deg)`;
      card.style.opacity = '0';
    });
  });
}

//ìŠ¹ë¦¬ í‘œì‹œ
function showWin() {
  cardFirework();   // ğŸ† ë¨¼ì € í„°íŠ¸ë¦¬ê³ 

  const o = document.getElementById('winOverlay');
  o.style.display = 'flex';

  document.body.style.pointerEvents = 'none';
  o.style.pointerEvents = 'auto';
}


//í…ŒìŠ¤íŠ¸
function forceWin() {
  // ëª¨ë“  ì¹´ë“œ ìˆ˜ì§‘
  const allCards = [
    ...stock,
    ...waste,
    ...tableau.flat(),
    ...foundations['â™ '],
    ...foundations['â™¥'],
    ...foundations['â™¦'],
    ...foundations['â™£']
  ];

  // ì´ˆê¸°í™”
  stock = [];
  waste = [];
  tableau = [[],[],[],[],[],[],[]];
  foundations = { 'â™ ':[], 'â™¥':[], 'â™¦':[], 'â™£':[] };

  // foundationì— ì •ë ¬í•´ì„œ ë„£ê¸°
  allCards.forEach(c => {
    c.faceUp = true;
    foundations[c.suit].push(c);
  });

  render();
  checkWin();
}


// ëª¨ë°”ì¼ í„°ì¹˜ìš© ì¹´ë“œ ì´ë™
let touchStartCard = null;
let touchStartFrom = null;
let touchStartY = 0;
let touchStartX = 0;

document.addEventListener('touchstart', e => {
    const el = e.target.closest('.card');
    if (!el) return;
	e.preventDefault(); // ì¹´ë“œ í„°ì¹˜ì¼ ë•Œë§Œ

    const id = parseInt(el.getAttribute('data-card-id'));
    touchStartCard = findCardById(id);
    touchStartFrom = findCardFrom(touchStartCard);

    touchStartY = e.touches[0].clientY;
    touchStartX = e.touches[0].clientX;

    e.preventDefault();
});

document.addEventListener('touchmove', e => {
    if (!touchStartCard) return;
    const moveY = e.touches[0].clientY - touchStartY;
    const moveX = e.touches[0].clientX - touchStartX;
    const el = document.querySelector(`.card[data-card-id='${touchStartCard.id}']`);
    el.style.transform = `translate(${moveX}px, ${moveY}px)`;
});

document.addEventListener('touchend', e => {
    if (!touchStartCard) return;

    const el = document.querySelector(
      `.card[data-card-id='${touchStartCard.id}']`
    );
    el.style.transform = '';

    const touch = e.changedTouches[0];
    const targetEl = document.elementFromPoint(touch.clientX, touch.clientY);
    let targetPile = targetEl?.closest('.pile');

    // =============================
    // â­ 1ï¸âƒ£ foundation ìœ„ì— ë“œë¡­
    // =============================
    if (targetPile?.classList.contains('foundation')) {
        selectedCard = touchStartCard;
        selectedFrom = touchStartFrom;
        onFoundationClick({
            type: 'foundation',
            suit: targetPile.dataset.suit
        });
    }

    // =============================
    // â­ 2ï¸âƒ£ tableau ìœ„ì— ë“œë¡­
    // =============================
    else if (targetPile?.parentElement?.id === 'tableau') {
        selectedCard = touchStartCard;
        selectedFrom = touchStartFrom;
        onPileClick({
            type: 'tableau',
            index: Array.from(
              document.querySelectorAll('#tableau .pile')
            ).indexOf(targetPile)
        });
    }

    // =============================
    // â­ 3ï¸âƒ£ ê·¸ëƒ¥ íƒ­ â†’ foundation ìë™ ì´ë™
    // =============================
    else {
        autoMoveToFoundation(touchStartCard, touchStartFrom);
    }

    touchStartCard = null;
    touchStartFrom = null;
});

// í—¬í¼: ì¹´ë“œ ID â†’ ì¹´ë“œ ê°ì²´
function findCardById(id) {
    for (let col of tableau) {
        for (let c of col) if (c.id === id) return c;
    }
    for (let c of waste) if (c.id === id) return c;
    for (let s of suits) {
        for (let c of foundations[s]) if (c.id === id) return c;
    }
    for (let c of stock) if (c.id === id) return c;
    return null;
}

// í—¬í¼: ì¹´ë“œ ê°ì²´ â†’ fromInfo
function findCardFrom(card) {
    for (let i=0;i<tableau.length;i++) if (tableau[i].includes(card)) return { type:'tableau', index:i };
    if (waste.includes(card)) return { type:'waste' };
    for (let s of suits) if (foundations[s].includes(card)) return { type:'foundation', suit:s };
    return null;
}

document.getElementById('testAutoBtn').onclick = () => {
  forceAutoCompleteTest();
};

function forceAutoCompleteTest() {
  // ì „ì²´ ì¹´ë“œ ìˆ˜ì§‘
  const all = [
    ...stock,
    ...waste,
    ...tableau.flat(),
    ...Object.values(foundations).flat()
  ];

  // ì´ˆê¸°í™”
  stock = [];
  waste = [];
  tableau = [[], [], [], [], [], [], []];
  foundations = { 'â™ ': [], 'â™¥': [], 'â™¦': [], 'â™£': [] };

  // value ì •ë ¬ìš©
  const order = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

  // ìŠˆíŠ¸ë³„ ë¶„ë¦¬
  const bySuit = { 'â™ ':[], 'â™¥':[], 'â™¦':[], 'â™£':[] };
  all.forEach(c => {
    c.faceUp = true;
    bySuit[c.suit].push(c);
  });

  // foundationì— A~Q ìˆœì„œë¡œ ë„£ê¸°
  Object.keys(bySuit).forEach(suit => {
    bySuit[suit]
      .sort((a,b) => order.indexOf(a.value) - order.indexOf(b.value))
      .forEach(card => {
        if (card.value !== 'K') {
          foundations[suit].push(card);
        }
      });
  });

  // KëŠ” tableauì— í•˜ë‚˜ì”©
  Object.keys(bySuit).forEach((suit, i) => {
    const king = bySuit[suit].find(c => c.value === 'K');
    if (king) tableau[i].push(king);
  });

  render();
  updateAutoCompleteButton();
}

function isAutoCompleteAvailable() {
  if (stock.length > 0) {
    return false;
  }

  if (waste.length > 0) {
    return false;
  }

  // tableau ëª¨ë“  ì¹´ë“œ ì•ë©´ í™•ì¸
  for (let i = 0; i < tableau.length; i++) {
    for (let j = 0; j < tableau[i].length; j++) {
      if (!tableau[i][j].faceUp) {
        return false;
      }
    }
  }
  return true;
}
createDeck();
deal();
render();
</script>
</body>
</html>
